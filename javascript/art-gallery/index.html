<!DOCTYPE html>
<html lang="en">

<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="My midjourney AI art" />

<title>Gallery Art</title>

<meta property="og:image" content="https://cdn.midjourney.com/28df4066-dc0c-4741-a3da-3120c0b547c1/grid_0_384_N.webp" />
<meta property="og:description" content="Gallery of art generated through Midjourney AI" />

<style>
    html {
        background-color: rgb(1, 5, 19);
        background-image: url(data:image/png;base64,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);
    }

    body {
        /* prevent the exceeds the viewport width*/
        overflow-x: hidden;
        /* reset margin for all user agent and browser*/
        margin: 0;
    }

    #github-icon {
        position: absolute;
        top: 12px;
        right: 12px;
        transition: transform 0.2s ease-out;
    }

    #github-icon:hover {
        /* Can i use with transform -> 98% user can access */
        transform: scale(1.1);
    }

    .box {
        overflow: hidden;
        background-color: rgb(34, 36, 53);
        box-shadow: 0 0px 2px 0 rgba(255, 255, 255, 0.2)
            /* shadow acting as border. Won't effect layout*/
            , 0 4px 28px 0 rgba(0, 0, 0, 0.4)
            /* acutal shadow*/
        ;
        border-radius: 16px;
        background-size: 100%;
        background-repeat: no-repeat;
        position: absolute;
    }

    .prompt {
        position: absolute;
        width: 100%;
        box-sizing: border-box;
        color: rgb(192, 198, 205);
        padding: 8px 12px 0px 12px;
        font-size: 16px;
        /* using for webkit-clamp -> limit display rows of words  */
        display: -webkit-box;
        -webkit-box-orient: vertical;
    }

    .prompt::before {
        content: "‚ùù";
        color: rgb(122, 126, 130);
        padding-right: 4px;
    }
</style>

<head />

<body>
    <a href="/" target="_blank" id="github-icon">
        <!-- Keep only something need from github logo -->
        <svg height="32" width="32" viewBox="0 0 16 16">
            <path
                d="M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z"
                fill="#fff">
            </path>
        </svg>
    </a>
    <script>
        "use strict"

        // === static DOM initialization. Just 1 in this app. The more you have here the more your app looks like a PDF document. Minimize
        // with me, I think it help have a bottom space for the app
        let dummyPlaceholder = document.createElement('div')
        dummyPlaceholder.style.position = 'absolute'
        dummyPlaceholder.style.width = '1px'
        document.body.append(dummyPlaceholder)

        // spring physics

        // spring animation step. Normaly 4 step for 60 fps (1/60 => 16.6 ms/ frame) and 2 for 120fps(1/120 => 8.3ms/frame)

        // 4ms/ step
        const msPerAnimationStep = 4
        function spring(pos, v = 0, k = 290, b = 30) {
            return { pos, dest: pos, v, k, b } //  k = stiffness, b = damping
        }

        function springStep(config) {
            // Inspired by  https://blog.maximeheckel.com/posts/the-physics-behind-spring-animations/
            const t = msPerAnimationStep / 1000
            const { pos, dest, v, k, b } = config

            const Fspring = -k * (pos - dest) // kg / s^2
            const Fdamper = -b * v // kg / s

            const a = Fspring + Fdamper // mass is 1, so not need to divided
            const newV = v + a * t
            const newPos = pos + newV * t;

            config.pos = newPos, config.v = newV;
        }

        function springGoToEnd(config) {
            config.pos = config.dest;
            config.v = 0
        }

        function clamp(min, v, max) {
            return v > max ? max : v < min ? min : v
        }

        // constant layour metrics. The rest is dynamic
        const promptPaddingBottom = 8
        const promptSizeY = 47 + promptPaddingBottom
        const prompt1DSizeY = 64 + promptPaddingBottom
        const boxesGapX = 24, boxesGapY = 24
        const boxes1DGapX = 52, boxes1DGapY = 28
        const windowPaddingTop = 40
        const gapToPeek = windowPaddingTop // show some gap at the top of page to first element in row
        const hitArea1DSizeX = 100 // left and right click region in 1D mode

        function colsBoxMaxSizeXF(containerSizeX) {

            // that size for mobile, when make sure in mobile not display 2 cols in same row
            const boxMinSizeX = 220

            // how many cols should show in the window, ?? why - boxesGapX
            // we have gap + item + gap + item + gap => containerX - boxesGapX => Space for item (boxesGap + boxContainer) => the boxContainer ~ boxMinSizeX
            const cols = clamp(1, Math.floor((containerSizeX - boxesGapX) / (boxMinSizeX + boxesGapX)), 7)

            // the maximun width of the box 
            const boxMaxSizeX = (containerSizeX - boxesGapX - cols * boxesGapX) / cols
            return { cols, boxMaxSizeX }
        }

        // state.
        let animatedUntilTime = null
        let reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)')
        // ! What is this
        let cursor
        let anchor = 0
        let windowSizeX = document.documentElement.clientWidth
        let scrollTop = window.scrollTop

        let inputs = {
            pointer: { x: -Infinity, y: -Infinity },
            key: null,
            clickedTarget: null
        }

        let data;
        {
            const windowSizeY = document.documentElement.clientHeight
            const { cols, boxMaxSizeX } = colsBoxMaxSizeXF(windowSizeX)
            const imgMaxSizeY = boxMaxSizeX + 100


            data = [
                { id: 'daa6883b-75ae-4805-9fe8-d394006ca8ca/0_1', w: 1024, h: 1024, prompt: `Apple WWDC promo, dan mumford` },
                { id: '0dcaf55a-6ece-42b1-a0b3-eb753d108415/0_3', w: 1424, h: 848, prompt: `Everything everywhere all at once, bold outlines` },
                { id: '037086ce-0dec-4888-8938-13ef27b49c9d/0_0', w: 1344, h: 896, prompt: `Kid's back, low angle, staring up at mobius spaceship landing in ancient china` },
                { id: 'cfd235ab-89b2-4834-9544-19768f160d2a/0_1', w: 1344, h: 896, prompt: `Cute and fluffy marshmallow modern mansion` },
                { id: 'ab740a8e-54af-452a-9b74-7b8cb233c025/grid_0', w: 1024, h: 1024, prompt: `Voronoi 3D printed cup taking roots` },
                { id: 'bcf32fdc-6d81-40f0-9063-d67cb402ea2a/grid_0', w: 1344, h: 1024, prompt: `Marble sculpture of an orange, museum gallery, exhibit` },
                { id: 'eb145f80-0196-4557-8560-e33637a3a807/grid_0', w: 846, h: 1728, prompt: `hourglass heart, liquid, grand canyon background` },
                { id: 'e7096121-02c0-4b46-b74e-c8d50f1cf82f/grid_0', w: 846, h: 1728, prompt: `hourglass heart, liquid, dynamic background` },
                { id: '604af437-f76b-4c7f-b778-1a3bf6ad663b/grid_0', w: 1024, h: 1024, prompt: `Golden retriever rising from the thick smokes, silhouette, contour` },
                { id: 'b6beb80d-b006-45e0-a06d-5e482b541571/grid_0', w: 2304, h: 1536, prompt: `Jupiter sitting on a chair on Saturn` },
                { id: 'c745ac87-7a5a-4f6e-a44e-c492e5ba9a1f/grid_0', w: 1024, h: 1024, prompt: `beautiful hyperrealistic abstract neural network colony, morning dew, depth of field` },
                { id: 'a70b5a2e-046c-4e7c-a9d1-d1d9de5833dd/grid_0', w: 1024, h: 1024, prompt: `cute Christmas knolling` },
                { id: '30d33a33-9b5b-4947-b813-4d0c5c2f9939/grid_0', w: 1536, h: 1024, prompt: `Chinese mid autumn festival on Neptune, surrealism` },
                { id: 'fb622e95-814d-4f74-8ac0-04d266c8387d/grid_0', w: 1664, h: 2432, prompt: `eclipse in a bottle` },
                { id: '91a44825-dc86-4166-bd9a-4b547bcad830/grid_0', w: 1664, h: 2432, prompt: `eclipse in a bottle` },
                { id: '418aae43-2209-4d98-a2a9-b25d3b447e2c/grid_0', w: 1536, h: 1024, prompt: `city, interconnected cable wires toward giant server tower in the center, dan mumford, bright morning light` },
                { id: '8ea0f4da-a9fc-4880-8f71-f51bf6c7f3d1/grid_0', w: 1536, h: 1024, prompt: `city, interconnected cable wires toward giant server tower in the center, dan mumford, bright morning light` },
                { id: 'b4652c7e-44ee-4d3b-b385-9c5c237f177b/grid_0', w: 1536, h: 1024, prompt: `werewolf princess warrior, tower, Berserk manga style, black and white, by Kentaro Miura` },
                { id: '733a5b94-3f35-4357-8ef5-645d1a9bb942/grid_0', w: 1024, h: 1536, prompt: `silk-like silhouette of koi fish, abstract wall paper, volumetric lighting` },
                { id: '1c195159-f1b0-4f23-a605-dd30ad42bbe5/grid_0', w: 1536, h: 1024, prompt: `giant fearsome beast god descending upon the sky, james jean` },
                { id: '0a1d96be-c49e-4769-a45f-3581500f1e19/grid_0', w: 1024, h: 1024, prompt: `dancing female astronaut exploring a floating food planet, bold colors, bold outlines, tshirt design` },
                { id: '01c5a300-1597-4f45-99f8-c9cafe21925c/grid_0', w: 1536, h: 1024, prompt: `damascus steel metal zebra in a museum exhibit, dynamic running pose, bright morning daylight, low angle` },
                { id: 'b88c0228-6442-4892-83ad-99cac2059abc/grid_0', w: 1024, h: 1536, prompt: `incredibly overloaded salmon crab shrimp octopus beef tomato lettuce onion noodle tornado floating tilted burger, promo photoshoot, spinning motion, explosive sea waves background, bright daylight` },
                { id: '2ca7a0f7-9153-45ce-be2b-1fc89327f61b/grid_0', w: 2304, h: 1536, prompt: `futuristic qipao, pink seamless astronaut skirt, sitting cross-legged at a floating space cafe, looking at camera, high angle, depth of field` },
                { id: 'ec03f17f-d94e-46cb-999b-9c1678943ce1/grid_0', w: 2304, h: 1536, prompt: `futuristic qipao, pink seamless astronaut skirt, sitting cross-legged at a floating space cafe, looking at camera, high angle, depth of field` },
            ].map((d, i) => {
                // get aspect ratio of the image
                const ar = d.w / d.h
                // get the new size for width of image, it is the min value of origin width, max size of the box contain image or the width from maximun of the image height
                const sizeX = Math.min(d.w, boxMaxSizeX, imgMaxSizeY * ar)
                // from with width => height of image
                const sizeY = sizeX / ar + promptSizeY

                let node = document.createElement('div')
                node.className = "box"
                node.style.backgroundImage = `url(https://cdn.midjourney.com/${d.id}_384_N.webp)`

                let imgNode = document.createElement('img')

                let promptNode = document.createElement('figcaption')
                promptNode.className = "prompt"
                promptNode.textContent = d.prompt

                node.append(imgNode, promptNode)

                return {
                    id: d.id,
                    ar, // aspect ratio
                    naturalSizeX: d.w,
                    sizeX: spring(sizeX),
                    sizeY: spring(sizeY),
                    x: spring(Math.floor(i / cols) * -windowSizeX - windowSizeX),
                    y: spring(windowSizeY + Math.floor(i / cols) * imgMaxSizeY),
                    scale: spring(1),
                    // for brightness and blur
                    fxFactor: spring(20),
                    node
                }
            })
        }

        function springForEach(f) {
            for (let d of data) {
                f(d.sizeX); f(d.sizeY); f(d.x); f(d.y); f(d.scale); f(d.fxFactor)
            }
        }

        // check box hit in 2D array
        function hit2DMode(data, pointerX, pointerY) {
            for (let i = 0; i < data.length; i++) {
                let { x, y, sizeX, sizeY } = data[i]
                if (x.dest <= pointerX && pointerX < x.dest + sizeX.dest && y.dest <= pointerY && pointerY < y.dest + sizeY.dest) {
                    return i
                }
            }
            return null
        }

        // check box hit in 1D array
        function hit1DMode(data, focused, windowSizeX, pointerX) {
            // start - [space] - mid - [space] - end, start and end have same width with 
            // hit Areasize 1D the hit box when occur 
            // in left => when current focused > 0 and cusor will from 0 -> hitAreaSize1D => new hit will focus -1, but limit in 0
            // in right => when curent focused < data.length - 1 and cursor will from windowSizeX - hitAreasize1D => new hit will focus + 1, but limit at data.length - 1
            return focused > 0 && 0 <= pointerX && pointerX <= hitArea1DSizeX ? Math.max(0, focused - 1) // left
                : focused < data.length - 1 && pointerX >= windowSizeX - hitArea1DSizeX ? Math.min(data.length - 1, focused + 1) // right
                    : null
        }

        function render(now) {
            // step1: batched DOM reads => avoid accidental DOM read and write interleaving

            const newWindowSizeX = document.documentElement.clientWidth
            const windowSizeY = document.documentElement.clientHeight

            const animationDisabled = reducedMotion.matches
            const currentScrollTop = window.scrollY
            const hashImageId = window.location.hash.slice(1)

            let focused = null;
            for (let i = 0; i < data.length; i++) {
                if (data[i].id === hashImageId) focused = i
            }

            let newFocused = focused

            const pointerXLocal = inputs.pointer.x + window.scrollX, pointerYLocal = inputs.pointer.y + currentScrollTop

            // step2: handle inputs=related state change

            if (inputs.clickedTarget !== null) {
                if (inputs.clickedTarget.tagName === "FIGCAPTION") {

                } else if (focused === null) {
                    newFocused = hit2DMode(data, pointerXLocal, pointerYLocal)
                } else {
                    newFocused = hit1DMode(data, focused, newWindowSizeX, pointerXLocal)
                }
            }

            // step3:
            const { cols, boxMaxSizeX } = colsBoxMaxSizeXF(newWindowSizeX)
            let boxes2DSizeX = [], boxes2DSizeY = [], rowsTop = [windowPaddingTop] // length: number of rows + 1
            {
                // store the value of highest card in 1 rows
                let rowMaxSizeY = 0;
                for (let i = 0; i < data.length; i++) {
                    let d = data[i]
                    // get max hight the image can get
                    const imgMaxSizeY = d.ar === 1 ? boxMaxSizeX * 0.85 // square make layout not feel correlatively
                        : d.ar < 1 ? boxMaxSizeX * 1.05  // vertical images look a mit small, grow it
                            : boxMaxSizeX
                    // get new size  for width
                    const sizeX = Math.min(d.naturalSizeX, boxMaxSizeX, imgMaxSizeY * d.ar)
                    // get new size for height
                    const sizeY = sizeX / d.ar + promptSizeY
                    boxes2DSizeX.push(sizeX)
                    boxes2DSizeY.push(sizeY)
                    rowMaxSizeY = Math.max(rowMaxSizeY, sizeY)
                    // last box of the row or last box ever
                    if (i % cols === cols - 1 || i === data.length - 1) {
                        rowsTop.push(rowsTop.at(-1) + rowMaxSizeY + boxesGapY)
                        rowMaxSizeY = 0
                    }
                }
            }

            // layout shifted, keep the box in the same place to prevent annoying layout jumps while view
            let adjustedScrollTop = currentScrollTop
            let newAnchor = anchor
            const hoverMagnetFactor = 40

            if (newFocused == null) {

                if (focused !== null) {
                    // from 1D to 2D, dismiss
                }

                // calcute boxes positions, in 2D view
                for (let i = 0; i < data.length; i++) {
                    let d = data[i]
                    const sizeX = boxes2DSizeX[i], sizeY = boxes2DSizeY[i]
                    // find the current row for render
                    const currentRow = Math.floor(i / cols)
                    const rowMaxSizeY = rowsTop[currentRow + 1] - boxesGapY - rowsTop[currentRow]
                    d.sizeX.dest = sizeX
                    d.sizeY.dest = sizeY
                    d.x.dest = boxesGapX + (boxMaxSizeX + boxesGapX) * (i % cols) + (boxMaxSizeX - sizeX) / 2
                    d.y.dest = rowsTop[currentRow] + (rowMaxSizeY - sizeY) / 2
                    d.scale.dest = 1
                    d.fxFactor.dest = 1
                }

                const hit = hit2DMode(data, pointerXLocal, pointerYLocal)
                if (hit === null) cursor = 'auto'
                else {
                    cursor = 'zoom-in'
                    let { x, y, sizeX, sizeY, scale } = data[hit]
                    x.dest += (pointerXLocal - (x.dest + sizeX.dest / 2)) / hoverMagnetFactor
                    y.dest += (pointerYLocal - (y.dest + sizeY.dest / 2)) / hoverMagnetFactor
                    scale.dest = 1.02
                }


                // first element in row with top === gapToPeek => adjust for it
                const anchorY = data[anchor].y.dest - gapToPeek
                if (newWindowSizeX !== windowSizeX) {
                    adjustedScrollTop = Math.max(0, anchorY)
                }


                // find the new anchor if current one moved too much
                if (adjustedScrollTop !== scrollTop && Math.abs(anchorY - adjustedScrollTop) > windowSizeY / 10) {
                    // new anchor is picked from left most column
                    for (newAnchor = 0; newAnchor < data.length; newAnchor += cols) {
                        let d = data[newAnchor]
                        // find the 1st box whose bottom exceed 20% of window height
                        if (d.y.dest + d.sizeY.dest - adjustedScrollTop > windowSizeY / 5) break
                    }
                }
            } else {
                // 1D mode
                const img1DSizeY = windowSizeY - windowPaddingTop - prompt1DSizeY - boxes1DGapY
                const box1DMaxSizeX = newWindowSizeX - boxes1DGapX * 2 - hitArea1DSizeX * 2

                // from right edge of the box and find the left edge of the very first box
                let currentLeft = hitArea1DSizeX + boxes1DGapX
                for (let i = newFocused - 1; i >= 0; i--) {
                    let d = data[i]
                    const imgSizeX = Math.min(d.naturalSizeX, box1DMaxSizeX, img1DSizeY * d.ar) * 0.7
                    currentLeft -= imgSizeX + boxes1DGapX
                }

                // imagination
                // box1 - box2 - box 3(display) - box4 - box5
                // first time -> find the box1 left distant => current Left, and each image will display only 0.7 for actualy size
                // and then loop all image in 

                // calculate boxed position
                for (let i = 0; i < data.length; i++) {
                    let d = data[i]
                    // if image is focuse => size -> 1, else size just 0.7
                    const imgSizeX = Math.min(d.naturalSizeX, box1DMaxSizeX, img1DSizeY * d.ar) * (i === newFocused ? 1 : 0.7)
                    const boxSizeY = imgSizeX / d.ar + prompt1DSizeY

                    d.sizeX.dest = imgSizeX
                    d.sizeY.dest = boxSizeY


                    // (windowSizeY - boxSizeY)/ 2 => from top of screen to top of box, adjusted scroll top?
                    d.y.dest = Math.max(windowPaddingTop, (windowSizeY - boxSizeY) / 2 + adjustedScrollTop)
                    d.x.dest = i === newFocused ? (newWindowSizeX - imgSizeX) / 2 : currentLeft

                    d.scale.dest = 1
                    d.fxFactor.dest = i === newFocused ? 1 : 0.2

                    currentLeft = i === newFocused ? newWindowSizeX - hitArea1DSizeX : currentLeft + imgSizeX + boxes1DGapX
                }

                const hit = hit1DMode(data, newFocused, newWindowSizeX, pointerXLocal)
                console.log(hit)
                if (hit === null) cursor = 'zoom-out'
                else {
                    // hover to left or right image
                    cursor = 'zoom-in'
                    let { x, y, sizeX, sizeY, scale, fxFactor } = data[hit]
                    x.dest += (pointerXLocal - (x.dest + sizeX.dest / 2)) / hoverMagnetFactor
                    y.dest += (pointerYLocal - (y.dest + sizeY.dest / 2)) / hoverMagnetFactor
                    scale.dest = 1.02
                    fxFactor.dest = 0.5
                }
            }



            // ensure that no matter how the scrolling is abruptly adjusted, the boxes on the screen don't suddenly jump too. When going 1D->2D mode where the dismissed image might be far from the initial one, or when resizing causes layout shifts, the boxes now stay unaffected!
            for (let { y } of data) y.pos += adjustedScrollTop - currentScrollTop


            // step 4: run animation

            // when first time render => the animation === now
            let newAnimatedUntilTime = animatedUntilTime ?? now

            // now is timeStamp props from requestAnimationFrame => the time sometime random -> not only 4ms 
            // so we need found the how many steps between Refresh Frame call
            const steps = Math.floor((now - newAnimatedUntilTime) / msPerAnimationStep)
            newAnimatedUntilTime += steps * msPerAnimationStep
            let stillAnimating = false


            if (animationDisabled) springForEach(springGoToEnd)
            else {
                springForEach(s => {
                    for (let i = 0; i < steps; i++) springStep(s)
                    // too close => done animation
                    if (Math.abs(s.v) < 0.01 && Math.abs(s.dest - s.pos) < 0.01) springGoToEnd(s)
                    else stillAnimating = true
                })
            }


            // step 5: render, Batch DOM writes
            const browserUIMaxSizeTop = 100, browserUIMaxSizeBottom = 150
            for (let i = 0; i < data.length; i++) {
                let d = data[i]

                let { node } = d, img = node.children[0], promt = node.children[1]

                // only draw what's visible on screen
                if (d.y.pos - adjustedScrollTop <= windowSizeY + browserUIMaxSizeBottom &&
                    d.y.pos + d.sizeY.pos - adjustedScrollTop >= -browserUIMaxSizeTop
                ) {
                    node.style.width = `${d.sizeX.pos}px`
                    node.style.height = `${d.sizeY.pos}px`
                    node.style.transform = `translate3d(${d.x.pos}px, ${d.y.pos}px, 0) scale(${d.scale.pos})`
                    node.style.filter = `brightness(${d.fxFactor.pos * 100}%)`

                    promt.style.top = `${d.sizeX.pos / d.ar}px`
                    promt.style.lineClamp = promt.style.webkitLineClamp = 2
                    promt.style.overflow = "hidden"

                    img.style.display = "none"

                    if (node.parentNode === null) {
                        document.body.appendChild(node)
                    }

                } else if (node.parentNode != null) {
                    document.body.removeChild(node)
                }
            }

            // update dummy height for better bottom space
            dummyPlaceholder.style.height = `${rowsTop.at(-1)}px`


            // step 6: update and prepare for next frame
            if (adjustedScrollTop !== currentScrollTop) window.scrollTo({ top: adjustedScrollTop })
            if (newFocused !== focused) {
                window.history.pushState(null, '', `${window.location.pathname}${window.location.search}${newFocused == null ? '' : '#' + data[newFocused].id}`)
            }
            inputs.clickedTarget = null
            animatedUntilTime = stillAnimating ? newAnimatedUntilTime : null
            windowSizeX = newWindowSizeX
            scrollTop = adjustedScrollTop

            anchor = newAnchor

            return stillAnimating

        }


        // render and schedule rendering
        function scheduleRender(debugForceRender) {

            window.requestAnimationFrame(function renderAndMaybeScheduleAnotherRender(now) {
                if (render(now)) scheduleRender()
            })
        }

        scheduleRender()

        window.addEventListener("resize", () => scheduleRender())
        window.addEventListener("scroll", () => scheduleRender())
        window.addEventListener('mousemove', (e) => {
            inputs.pointer.x = e.pageX - window.scrollX;
            inputs.pointer.y = e.pageY - window.scrollY
            scheduleRender()
        })
        window.addEventListener('click', (e) => {
            inputs.clickedTarget = e.target
            inputs.pointer.x = e.pageX - window.scrollX;
            inputs.pointer.y = e.pageY - window.scrollY
            scheduleRender()
        })

    </script>
</body>

</html>